#pragma kernel GenerateHeight
#pragma kernel InitSnowTotals
#pragma kernel AddSnowHeight
#pragma kernel ClearSnowTotals
#pragma kernel PopulateGrid
#pragma kernel ComputeForces
#pragma kernel ApplyForces
#pragma kernel UpdateSnowTotals
#pragma kernel SetPressure
#pragma kernel ClearGrid
#include "../Scripts/Noises.cginc"

//TODO: put to global defines
#define PI2 6.28318530718f
#define G 9.81f

struct Cell
{
    int3 gridIndex;
    int index;
    float3 WSposition;
    float indentAmount;
    float3 pressure;
    float hardness;
    float3 appliedPressure;
    float density;
    float temperature;
    float grainSize;
    float mass;
    float massOver;
    int isOccupied; //TO-DO - enum here
};

struct CollisionData
{
    float3 position;
    float3 pressure;
};

struct ColumnData
{
    float height;
    float groundHeight;
    float mass;
    float mass_temp;
};

 RWStructuredBuffer<Cell> cellGridBuffer;
 RWStructuredBuffer<ColumnData> snowTotalsBuffer;
 RWStructuredBuffer<CollisionData> collisionsBuffer;

shared RWTexture2D<float4> GroundHeightMap;
shared RWTexture2D<float4> Debug;

int texResolution;
float planeSideSize;
float3 planeCenter;

int cellBufferLength;
int3 gridDimensions;
float cellSize;
float3 gridCenter;

float time;
float deltaTime;
float simulationSpeed;
float timeScale;

int3 particlesPerAxis;

float V_cell;

float snowAddedHeight;
float airTemperature;
float groundTemperature;
float maxSnowDensity;
float freshSnowDensity;

float h_d_p;
float h_c_p;
float k_d_p;
float k_c_p;

float fsmooth(float x, float z)
{
    return z * (1.0 - 1.0 / (x / z + 1.0));
}

int2 posTocoords(float3 position)
{
    float mapX = ((-position.x + planeSideSize / 2.0f - planeCenter.x) / (float) planeSideSize);
    float mapY = ((-position.z + planeSideSize / 2.0f - planeCenter.z) / (float) planeSideSize);
    int2 coords = int2(round(mapX * (texResolution - 1.0f)), round(mapY * (texResolution - 1.0f)));
    return coords;
}

int getGridIndexFromPosition(float3 position)
{
    int3 cellId = round(floor(position / (float) cellSize) - (gridCenter - ((float3) gridDimensions) * 0.5f) - float3(cellSize / 4.0f, cellSize / 4.0f, cellSize / 4.0f));
    int index = cellId.x + gridDimensions.x * cellId.y + gridDimensions.y * gridDimensions.x * cellId.z;
    return clamp(index, 0, cellBufferLength - 1);
}

bool isWithinGrid(float3 position)
{
    float3 boundsMin = gridCenter - ((float3) gridDimensions) * 0.5f * cellSize;
    float3 boundsMax = gridCenter + ((float3) gridDimensions) * 0.5f * cellSize;
    
    if (
        (position.x < boundsMin.x) || (position.x > boundsMax.x) ||
        (position.y < boundsMin.y) || (position.y > boundsMax.y) ||
        (position.z < boundsMin.z) || (position.z > boundsMax.z))
    {
        return false;
    }
    return true;
}

uint3 clipCellId(uint3 id)
{
    uint3 index_3d = id;
    index_3d.x = min(max(index_3d.x, 0), gridDimensions.x - 1);
    index_3d.y = min(max(index_3d.y, 0), gridDimensions.y - 1);
    index_3d.z = min(max(index_3d.z, 0), gridDimensions.z - 1);
    
    return index_3d;
}

uint indexTextToArray(uint2 id)
{
    uint index = (id.x) + texResolution * (id.y);
    return index;
}

uint indexTexToGrid(uint3 id)
{
    float3 cell_id_ratio;
    uint3 cell_id;
    cell_id_ratio.x = ((float) id.x / (float) (texResolution - 1));
    cell_id_ratio.y = ((float) id.y / (float) (texResolution - 1));
    
    cell_id.x = round(cell_id_ratio.x * (gridDimensions.x - 1));
    cell_id.z = round(cell_id_ratio.y * (gridDimensions.z - 1));
    cell_id.y = id.z;
    
    uint index = cell_id.x + gridDimensions.x * cell_id.y + gridDimensions.y * gridDimensions.x * cell_id.z;
    return index;
}

[numthreads(32, 32, 1)]
void GenerateHeight(uint3 id : SV_DispatchThreadID)
{
    //time *= timeScale;
    
    float2 uv = float2((float) id.x / (float) (texResolution - 1), (float) id.y / (float) (texResolution - 1));
   // float2 uvOffset = float2(time, 0.0f);
    //float heightMap = SimpleNoise(uv - uvOffset, 5) * 2.0f;
    
    //float heightMap = SimpleNoise(uv, 5) * 2.0f;
    float heightMap = 1.0f;
    GroundHeightMap[id.xy] = float4(heightMap.xxx, 1.0f);
    snowTotalsBuffer[indexTextToArray(id.xy)].groundHeight = heightMap;
    Debug[id.xy] = float4(heightMap.xxx, 1.0f);
}

[numthreads(32, 32, 1)]
void InitSnowTotals(uint3 id : SV_DispatchThreadID)
{
    // TODO: make it adaptive to the underlying ground height map and wind direction
    snowTotalsBuffer[indexTextToArray(id.xy)].height = snowAddedHeight; // init column heights
    snowTotalsBuffer[indexTextToArray(id.xy)].mass = 0.0f; // init column masses
}

//TO-DO: rename to clear snow totals
[numthreads(32, 32, 1)]
void ClearSnowTotals(uint3 id : SV_DispatchThreadID)
{
    snowTotalsBuffer[indexTextToArray(id.xy)].mass = 0.0f; // clear mass
    snowTotalsBuffer[indexTextToArray(id.xy)].mass_temp = 0.0f; // clear mass
}

[numthreads(32, 32, 1)]
void AddSnowHeight(uint3 id : SV_DispatchThreadID)
{
    snowTotalsBuffer[indexTextToArray(id.xy)].height += snowAddedHeight; 
    
}

//called every update
[numthreads(10, 10, 10)]
void PopulateGrid(uint3 id : SV_DispatchThreadID)
{
    int index = id.x + gridDimensions.x * id.y + gridDimensions.y * gridDimensions.x * id.z;
    Cell cell = cellGridBuffer[index];
    cell.WSposition = (float3((float) id.x + (float) cellSize / 4.0f, (float) id.y + (float) cellSize / 4.0f, (float) id.z + (float) cellSize / 4.0f) + (gridCenter - (float3) gridDimensions * 0.5f)) * cellSize;
    int2 coords = posTocoords(cell.WSposition);
    float groundLevel = GroundHeightMap[coords].x + planeCenter.y;
    float snowLevel = groundLevel + snowTotalsBuffer[indexTextToArray(coords)].height;
    
    if (cell.WSposition.y < groundLevel + cellSize * 0.5f)
    {
        cell.isOccupied = -2; //below ground
        cell.density = 100.0f;
        cell.temperature = groundTemperature;
    }
    else if (cell.WSposition.y < snowLevel + cellSize * 0.5f)
    {
        if (cell.isOccupied == -1) //if new snow is added
        {
            cell.density = freshSnowDensity;
            cell.temperature = airTemperature;
        }
        cell.isOccupied = 1; //below snow surface but above ground - inside snow pack
        float density = cell.density;
        float temperature = cell.temperature;
        //cell.hardness = (density * density * density * 0.001 + density * density * 0.01 +  density * 0.1) * 10; /** 10000.0f;*/
        //cell.hardness = pow(density, 3.99f) * 3.55;
        //cell.hardness = pow(density, h_d_p) * pow(0.1, h_c_p);
        //cell.hardness = pow(density, h_d_p) * pow(0.1, h_c_p) * pow(-temperature, h_d_p) * pow(0.1, h_c_p);
        //cell.hardness = - 0.16599 + 0.542153 * density - 0.08925*temperature + 0.447667*pow(density, 2)+ 0.159256*density*temperature - 0.01336*pow(temperature, 2) + 0.261043*pow(temperature,3) - 0.15863*pow(density, 2)*temperature + 0.022601*density*pow(temperature, 2) - 0.00032*pow(temperature, 3);
       
        float unit_conversion = pow(10.0f, -3.0f);
        density *= unit_conversion;
        cell.hardness = -0.16599 + 0.542153 * density - 0.08925 * temperature + 0.447667 * pow(density, 2) + 0.159256 * density * temperature - 0.01336 * pow(temperature, 2) + 0.261043 * pow(temperature, 3) - 0.15863 * pow(density, 2) * temperature + 0.022601 * density * pow(temperature, 2) - 0.00032 * pow(temperature, 3);
       
        //cell.hardness = -0.16599 + 0.542153 * density * unit_conversion - 0.08925 * temperature + 0.447667 * pow((density * unit_conversion), 2) + 0.159256 * (density * unit_conversion) * temperature - 0.01336 * pow(temperature, 2) + 0.261043 * pow(temperature, 3) - 0.15863 * pow((density * unit_conversion), 2) * temperature + 0.022601 * (density * unit_conversion) * pow(temperature, 2) - 0.00032 * pow(temperature, 3);
    }
    else
    {
        cell.isOccupied = -1; //free
        cell.density = 0.0f; //air
        cell.temperature = airTemperature;
    }
    
    cell.mass = cell.density * V_cell;
    cellGridBuffer[index] = cell;
}

[numthreads(1, 50, 1)]
void ComputeForces(uint3 id : SV_DispatchThreadID)
{
    uint3 id_clipped = clipCellId(id);
    int index = id_clipped.x + gridDimensions.x * (gridDimensions.y - 1 - id_clipped.y) + gridDimensions.y * gridDimensions.x * id_clipped.z; //iterate top to bottom
    Cell cell = cellGridBuffer[index];
    
    if (cell.isOccupied > -2)
    {
        float area = cellSize * cellSize;
        float3 upPos = cell.WSposition + float3(0, cellSize, 0);
        
        float3 appliedPressure = cell.appliedPressure;
        
        if (!isWithinGrid(upPos))
        {
            cell.massOver = 0.0f;
            cell.pressure = float3(0, -((cell.massOver + cell.mass) * G) / area, 0) + appliedPressure;
            cellGridBuffer[index] = cell;
            return;
        }
        int upperCellI = getGridIndexFromPosition(upPos);
        Cell upperCell = cellGridBuffer[upperCellI];
        
        cell.massOver = upperCell.massOver + upperCell.mass;
        cell.pressure = float3(0, -((cell.massOver + cell.mass) * G) / area, 0)
        +appliedPressure;
        cellGridBuffer[index] = cell;
    }
}

[numthreads(1, 50, 1)]
void ApplyForces(uint3 id : SV_DispatchThreadID)
{
    uint3 id_clipped = clipCellId(id);
    //int index = id.x + gridDimensions.x * (gridDimensions.y - 1 - id.y) + gridDimensions.y * gridDimensions.x * id.z;
    int index = id_clipped.x + gridDimensions.x * ( id_clipped.y) + gridDimensions.y * gridDimensions.x * id_clipped.z; //iterate top to bottom
    
    Cell cell = cellGridBuffer[index];
    cell.indentAmount = 0.0f;

    float pressure_y = cell.pressure.y;
    float3 pressure_dir = float3(0, 1, 0) * ((float) pressure_y / (float) abs(pressure_y));
    
    
    if (cell.density >= maxSnowDensity){
        cellGridBuffer[index] = cell;
        return;
    }
    
    float density = cell.density;
    float k_springCoefficient = pow(density, k_d_p) * pow(0.1f, k_c_p);
    float x = max(abs(pressure_y) - cell.hardness, 0.0f) / (float) k_springCoefficient; // alternative?
    x = abs(x);
    x *= deltaTime * timeScale;
    x = min(x, 0.99 * cellSize);
    
    
    if ((x > 0.0) && (cell.isOccupied > -1))
    {
        float cell_delimeter = max((cellSize - x), 0.0f);
        float V_lower = cellSize * cellSize * cell_delimeter;
        float V_upper = cellSize * cellSize * (cellSize - cell_delimeter);
        
        float Vnew_to_Vold = V_lower / V_cell;
        float density_lower = cell.density / (float) Vnew_to_Vold;
        float density_upper = 0.0f;
        
        float3 upPos = cell.WSposition + float3(0, cellSize, 0);
        if (isWithinGrid(upPos))
        {
           int upperCellI = getGridIndexFromPosition(upPos);
           Cell upperCell = cellGridBuffer[upperCellI];
           density_upper = upperCell.density;
        }
        float mass_lower = V_lower * density_lower;
        float mass_upper = V_upper * density_upper;
        
        cell.mass = (mass_lower + mass_upper);
        float density = (mass_lower + mass_upper) / (float) V_cell;
        float h_smooth = 0.86f;
        cell.density = min(density, maxSnowDensity * h_smooth) + fsmooth(max(density - maxSnowDensity * h_smooth, 0.0f), maxSnowDensity * (1-h_smooth));
        cell.indentAmount = x;
    }
    
    cellGridBuffer[index] = cell;
}

[numthreads(32, 32, 1)]
void UpdateSnowTotals(uint3 id : SV_DispatchThreadID)
{
    id.z = max(gridDimensions.z - 1 - id.z, 0); // iterate top to bottom
    int2 coords = id.xy;
    coords = int2(texResolution - 1, texResolution - 1) - coords;
    uint bufferIndex = indexTextToArray(coords);
    int cellIndex = indexTexToGrid(id);
    
    Cell cell = cellGridBuffer[cellIndex];
    
    float indentAmout = cell.indentAmount;
    
    ColumnData snowColumnTotals = snowTotalsBuffer[bufferIndex];
    
    snowColumnTotals.height -= indentAmout;
    if (cell.isOccupied > -1)
    {
        snowColumnTotals.mass_temp += cell.mass;
    }
    else if (cell.isOccupied == -2)
    {
        snowColumnTotals.mass = snowColumnTotals.mass_temp;
    }
    
    snowTotalsBuffer[bufferIndex] = snowColumnTotals;
}

[numthreads(1, 1, 1)]
void SetPressure(uint3 id : SV_DispatchThreadID)
{
    int index = id.x;
    CollisionData collision = collisionsBuffer[index];
    if (isWithinGrid(collision.position))
    {
        int cell_index = getGridIndexFromPosition(collision.position);
        Cell cell = cellGridBuffer[cell_index];
        cell.appliedPressure = collision.pressure;
        cellGridBuffer[cell_index] = cell;
    }
}

[numthreads(10, 10, 10)]
void ClearGrid(uint3 id : SV_DispatchThreadID)
{
    int index = id.x + gridDimensions.x * id.y + gridDimensions.y * gridDimensions.x * id.z;
    Cell cell = cellGridBuffer[index];
    cell.appliedPressure = float3(0.0f, 0.0f, 0.0f);
    cell.indentAmount = 0.0;
    cellGridBuffer[index] = cell;
}