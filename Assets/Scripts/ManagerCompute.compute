// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel GenerateHeight
#pragma kernel InitSnowHeight
#pragma kernel AddSnowHeight
#pragma kernel ClearSnowHeight
#pragma kernel PopulateGrid
#pragma kernel ComputeForces
#pragma kernel ApplyForces
#pragma kernel UpdateSnowTotals
#pragma kernel ClearGrid
#include "../Scripts/Noises.cginc"

#define PI2 6.28318530718f
#define G 9.81f

struct Cell
{
    int3 gridIndex;
    float3 WSposition;
    float3 force;
    float density;
    float indentAmount;
    float hardness;
    float temperature;
    float grainSize;
    float mass;
    float massOver;
    int index;
    int isOccupied; //TO-DO - enum here
};

struct Collider
{
    float3 velocity;
    float mass;
    float speed;
    float bottomSurfaceArea;
};

struct ColumnData
{
    float height;
    float mass;
    float averageDensity;
};

 RWStructuredBuffer<Cell> cellGridBuffer;
 RWStructuredBuffer<ColumnData> snowTotalsBuffer;

shared RWTexture2D<float4> GroundHeightMap;
shared RWTexture2D<float4> Debug;

int texResolution;
float planeSideSize;
float3 planeCenter;

int cellBufferLength;
int3 gridDimensions;
float cellSize;
float3 gridCenter;

float time;
float deltaTime;
float simulationSpeed;
float timeScale;

float dissipationAmount = 0.95f;
int3 particlesPerAxis;

float V_cell;

float snowAddedHeight;
float temperature;
float maxSnowDensity;
float freshSnowDensity;


int2 posTocoords(float3 position)
{
    float mapX = ((-position.x + planeSideSize / 2.0f - planeCenter.x) / (float) planeSideSize);
    float mapY = ((-position.z + planeSideSize / 2.0f - planeCenter.z) / (float) planeSideSize);
    int2 coords = int2(round(mapX * (texResolution - 1.0f)), round(mapY * (texResolution - 1.0f)));
    return coords;
}

int getGridIndexFromPosition(float3 position)
{
    int3 cellId = round(floor(position / (float) cellSize) - (gridCenter - ((float3) gridDimensions) * 0.5f) - float3(cellSize / 4.0f, cellSize / 4.0f, cellSize / 4.0f));
    int index = cellId.x + gridDimensions.x * cellId.y + gridDimensions.y * gridDimensions.x * cellId.z;
    return clamp(index, 0, cellBufferLength - 1);
}

bool isWithinGrid(float3 position)
{
    float3 boundsMin = gridCenter - ((float3) gridDimensions) * 0.5f * cellSize;
    float3 boundsMax = gridCenter + ((float3) gridDimensions) * 0.5f * cellSize;
    
    if (
        (position.x < boundsMin.x) || (position.x > boundsMax.x) ||
        (position.y < boundsMin.y) || (position.y > boundsMax.y) ||
        (position.z < boundsMin.z) || (position.z > boundsMax.z))
    {
        return false;
    }
    return true;
}

uint indexTextToArray(uint2 id)
{
    uint index = (id.x) + texResolution * (id.y);
    return index;
}

uint indexTexToGrid(uint3 id)
{
    float3 cell_id_ratio;
    uint3 cell_id;
    cell_id_ratio.x = ((float) id.x / (float) (texResolution - 1));
    cell_id_ratio.y = ((float) id.y / (float) (texResolution - 1));
    //cell_id.z = round((id.z) / (float) texResolution);
    
    cell_id.x = round(cell_id_ratio.x * (gridDimensions.x - 1));
    cell_id.z = round(cell_id_ratio.y * (gridDimensions.z - 1));
    cell_id.y = id.z;
    
    uint index = cell_id.x + gridDimensions.x * cell_id.y + gridDimensions.y * gridDimensions.x * cell_id.z;
    return index;
}

[numthreads(32, 32, 1)]
void GenerateHeight(uint3 id : SV_DispatchThreadID)
{
    //time *= timeScale;
    
    float2 uv = float2((float) id.x / (float) (texResolution - 1), (float) id.y / (float) (texResolution - 1));
   // float2 uvOffset = float2(time, 0.0f);
    //float heightMap = SimpleNoise(uv - uvOffset, 5) * 2.0f;
    
    //float heightMap = SimpleNoise(uv, 5) * 2.0f;
    float heightMap = 1.0f;
    GroundHeightMap[id.xy] = float4(heightMap.xxx, 1.0f);
    Debug[id.xy] = float4(heightMap.xxx, 1.0f);
}

[numthreads(32, 32, 1)]
void InitSnowHeight(uint3 id : SV_DispatchThreadID)
{
    // TODO: make it adaptive to the underlying ground height map and wind direction
    snowTotalsBuffer[indexTextToArray(id.xy)].height = snowAddedHeight; // init column heights
    snowTotalsBuffer[indexTextToArray(id.xy)].mass = 0.0f; // init column masses
    
}

//TO-DO: rename to clear snow totals
[numthreads(32, 32, 1)]
void ClearSnowHeight(uint3 id : SV_DispatchThreadID)
{
    snowTotalsBuffer[indexTextToArray(id.xy)].mass = 0.0f; // clear mass
}

[numthreads(32, 32, 1)]
void AddSnowHeight(uint3 id : SV_DispatchThreadID)
{
    snowTotalsBuffer[indexTextToArray(id.xy)].height += snowAddedHeight; 
    
}

//called every update
[numthreads(10, 10, 10)]
void PopulateGrid(uint3 id : SV_DispatchThreadID)
{
    int index = id.x + gridDimensions.x * id.y + gridDimensions.y * gridDimensions.x * id.z;
    Cell cell = cellGridBuffer[index];
    cell.WSposition = (float3((float) id.x + (float) cellSize / 4.0f, (float) id.y + (float) cellSize / 4.0f, (float) id.z + (float) cellSize / 4.0f) + (gridCenter - (float3) gridDimensions * 0.5f)) * cellSize;
    int2 coords = posTocoords(cell.WSposition);
    float groundLevel = GroundHeightMap[coords].x + planeCenter.y;
    float snowLevel = groundLevel + snowTotalsBuffer[indexTextToArray(coords)].height;
    
    if (cell.WSposition.y < groundLevel )
    {
        cell.isOccupied = -2; //below ground
        cell.density = 100.0f;
    }
    else if (cell.WSposition.y < snowLevel )
    {
        if (cell.isOccupied == -1) //if new snow is added
        {
            cell.density = freshSnowDensity;
        }
        cell.isOccupied = 1; //below snow surface but above ground - inside snow pack
        float density = cell.density;
       // cell.hardness = (density * density * density * 0.001 + density * density * 0.01 +  density * 0.1) * 10; /** 10000.0f;*/
        cell.hardness = density * density * density * 3.55;
    }
    else
    {
        cell.isOccupied = -1; //free
        cell.density = 0.0f; //air
    }
    
    cell.mass = cell.density * V_cell;
    cell.temperature = temperature;
    cellGridBuffer[index] = cell;
}

[numthreads(10, 10, 10)]
void ComputeForces(uint3 id : SV_DispatchThreadID)
{
    int index = id.x + gridDimensions.x * (gridDimensions.y -1 - id.y) + gridDimensions.y * gridDimensions.x * id.z; //iterate top to bottom
    Cell cell = cellGridBuffer[index];
    
    if (cell.isOccupied > -2)
    {
        //float m_total = cell.mass;
        float3 upPos = cell.WSposition + float3(0, cellSize, 0);
        
        //float3 appliedForce = float3(0, -100000.0f, 0);
        float3 appliedForce = float3(0, 0.0f, 0);
        
        if (!isWithinGrid(upPos))
        {
            cell.massOver = 0.0f + cell.mass;
            cell.force = float3(0, - cell.massOver * G, 0) + appliedForce;
            cellGridBuffer[index] = cell;
            return;
        }
        int upperCellI = getGridIndexFromPosition(upPos);
        Cell upperCell = cellGridBuffer[upperCellI];
    
        //int2 coords = posTocoords(cell.WSposition);
        //float groundLevel = GroundHeightMap[coords].x + planeCenter.y;
        //float snowLevel = groundLevel + snowTotalsBuffer[indexTextToArray(coords)].height;
    
        //while (upperCell.isOccupied > -2)
       // {
            //m_total += upperCell.mass;
            //upPos = upperCell.WSposition + float3(0, cellSize, 0);
            //if (!isWithinGrid(upPos))
            //{
            //    break;
            //}
            //upperCellI = getGridIndexFromPosition(upPos);
            //upperCell = cellGridBuffer[upperCellI];
       // }
        
        cell.massOver = upperCell.massOver + cell.mass;
        cell.force = float3(0, -cell.massOver * G, 0) + appliedForce;
        cellGridBuffer[index] = cell;
    }
}
[numthreads(10, 10, 10)]
void ApplyForces(uint3 id : SV_DispatchThreadID)
{
    int index = id.x + gridDimensions.x * max((gridDimensions.y - 1 - id.y), 0) + gridDimensions.y * gridDimensions.x * id.z;
    Cell cell = cellGridBuffer[index];
    cell.indentAmount = 0.0f;

    float force_y = cell.force.y;
    float3 force_dir = float3(0, 1, 0) * ((float) force_y / (float) abs(force_y));
    
    float density = cell.density;
    float k_springCoefficient = pow(density, 7) * pow(0.1f, 8);
    //float x = max(( abs(force_y) - cell.hardness), 0.0f) / (float) k_springCoefficient; // any force that is lower than the snows 
    float x =  abs(force_y)  / (float) k_springCoefficient; // alternative?
    x *= deltaTime * timeScale;
    
    
    if ((x > 0.0) /*&& (cell.density < maxSnowDensity)*/ && (cell.isOccupied > -1))
    {
        float cell_delimeter = max((cellSize - x), 0.0f);
        float V_lower = cellSize * cellSize * cell_delimeter;
        float V_upper = cellSize * cellSize * (cellSize - cell_delimeter);
        
        //float Vnew_to_Vold = cell_delimeter / (float) (cellSize);
        float Vnew_to_Vold = V_lower / V_cell;
        float density_lower = cell.density / (float) Vnew_to_Vold;
        float density_upper = 0.0f;
        
        float3 upPos = cell.WSposition + float3(0, cellSize, 0);
        if (isWithinGrid(upPos))
        {
           int upperCellI = getGridIndexFromPosition(upPos);
           Cell upperCell = cellGridBuffer[upperCellI];
           density_upper = upperCell.density;
        }
        float mass_lower = V_lower * density_lower;
        float mass_upper = V_upper * density_upper;
        
        cell.mass = (mass_lower + mass_upper);
        cell.density = (mass_lower + mass_upper) / (float) V_cell;
        cell.indentAmount = x;
    }
    
    cellGridBuffer[index] = cell;
}

[numthreads(32, 32, 1)]
void UpdateSnowTotals(uint3 id : SV_DispatchThreadID)
{
    id.z = max(gridDimensions.z - 1 - id.z, 0); // iterate top to bottom
    int2 coords = id.xy;
    uint bufferIndex = indexTextToArray(coords);
    int cellIndex = indexTexToGrid(id);
    
    Cell cell = cellGridBuffer[cellIndex];
    
    float indentAmout = cell.indentAmount;
    
    ColumnData snowColumnTotals = snowTotalsBuffer[bufferIndex];
    
    snowColumnTotals.height -= indentAmout;
    if (cell.isOccupied > -1)
    {
        snowColumnTotals.mass += cell.mass;
    }
    
    snowTotalsBuffer[bufferIndex] = snowColumnTotals;
}

[numthreads(10, 10, 10)]
void ClearGrid(uint3 id : SV_DispatchThreadID)
{
    int index = id.x + gridDimensions.x * id.y + gridDimensions.y * gridDimensions.x * id.z;
    Cell cell = cellGridBuffer[index];
    
    //cell.force = float3(0.0f, 0.0f, 0.0f);
    cellGridBuffer[index] = cell;
}